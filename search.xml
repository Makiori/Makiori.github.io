<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>/2021/04/20/blog/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h1><p>上一年建的博客，因为个人原因删除了。<br>主要就是当时选的主题过于复杂，后面不想整理。<br>再加上放了太多可能涉及版权问题的四格漫画。<br>（虽然说本来就经常做灰色地带的勾当）<br>一二月放寒假的时候，每天躺在床上什么都不想做，所以就拖到了开学。<br>但有动力做事的情况下，还是出了一系列的意外，就不多说了。<br>于是摸鱼摸了几个月之后，终于在19岁生日的时候，重新建好了自己的小地盘。<br>后面会专门写一篇关于如何用 Hexo+GitPages 建立个人博客的文章。<br>算是给自己留个记录，也希望能在以后帮到想建个人博客的朋友。</p>
<h1 id="关于现状"><a href="#关于现状" class="headerlink" title="关于现状"></a>关于现状</h1><p>这摸过去的几个月里，发生了很多事情，比如说我的人际关系就发生了翻天覆地的变化。<br>嘛，有相遇就会有分别，一段关系的结束或许会是另一段关系的开始呢？<br>而且我也深刻地认识到了自己在人际交往中的种种问题，<br>于是我注销掉了自己的微博账号，还退掉了许多已经没有交流的QQ群。<br>在圈子里面彻底消失，而且已经没有回归的机会了。<br>希望自己能在下一个圈子里有更为理想的形态。<br>我一直在盼望自己的人生会发生不同寻常的事情，<br>但当它已经在发生变化的时候，我却没有意识到。</p>
<h1 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h1><p>以后会在这里分享一下自己的学习情况，以及生活上各种各样的小事情。<br>还会稍微放一些翻译工作，如果还能有这样的工作机会的话，<br>又或者是还能遇到让自己兴奋的事物的话。<br>最后还有自己的脑洞，属于我的牧尾宇宙。<br>会慢慢地更新，能写多少就不知道了。<br>先放一个题目：《角落里的魔女》<br>嗯，然后还有很多想尝试的事情，比如说：制作游戏啊，到处旅行然后用视频记录下来之类的。<br>嘛，只有一次的人生，应该好好地享受。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>项目首战吐槽[第一弹]</title>
    <url>/2021/09/04/blog/%E9%A1%B9%E7%9B%AE%E9%A6%96%E6%88%98%E5%90%90%E6%A7%BD%E7%AC%AC%E4%B8%80%E5%BC%B9/</url>
    <content><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>上篇博客提到，最近在进行学习编程以来第一次正式的项目编写。虽然是跟着慕课网一步一步去写，但过程中还是能学习到不少知识。<br>为了记录自己学习的情况，于是便有了这个[项目首战吐槽] 这个栏目。<br>今回是第一弹，下面开始会聊聊目前在项目开发过程中发生的各种意外事件。（顺带一提，有部分原因是老胡不想听我发牢骚）</p>
<h1 id="关于课程"><a href="#关于课程" class="headerlink" title="关于课程"></a>关于课程</h1><p>首先，先黏一下课程的网址：<a href="https://coding.imooc.com/class/416.html">Spring Cloud + Vue 前后端分离 开发企业级在线视频课程系统</a>，感兴趣的朋友可以看看（x<br>SpringBoot：<a href="https://baike.baidu.com/item/Spring%20Boot/20249767?fr=aladdin">单应用开发框架</a><br>SpringCloud：<a href="https://baike.baidu.com/item/spring%20cloud/20269825?fr=aladdin">管理多个SpringBoot应用的微服务框架</a><br>Vue：<a href="https://cn.vuejs.org/v2/guide">用于构建用户界面的渐进式框架</a></p>
<h1 id="问题吐槽"><a href="#问题吐槽" class="headerlink" title="问题吐槽"></a>问题吐槽</h1><p>目前学习到第5章 单表管理功能前后端开发<br>这周的开发以来，发生过许多大大小小的意外<br>比如服务器的端口莫名被占用，使得模块无法顺利启动。<br>一开始没注意好报错信息，只知道一味回滚代码，导致浪费了一个中午的时间。</p>
<h2 id="问题发生"><a href="#问题发生" class="headerlink" title="问题发生"></a>问题发生</h2><p>而在本周末的分页功能开发中，发现了目前学习中比较大的意外。<br>集成了分页插件pagehelper，将20组数据插入数据库之后，发现网页并不能够将数据全部显示出来。<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/8.jpg?versionId=CAEQFxiBgICNi83O3RciIDQzNGQxN2QwMGZkNjQwZDI5YjNjMGRjZGUxY2FhYjA2" alt="数据正常显示情况"></p>
<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/7.jpg?versionId=CAEQFxiBgMDd8cDO3RciIDAxZjk2ZWYxZmUwOTRkMDBiZDc0ZjI1YjAzYTEzMmFh" alt="数据错误显示情况"></p>
<h2 id="原因追溯"><a href="#原因追溯" class="headerlink" title="原因追溯"></a>原因追溯</h2><p>既然前端出现了数据上的问题，那么后端会不会也有问题呢？<br>于是我查看了后端模块的运行情况，发现了问题所在。</p>
<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/3.jpg?versionId=CAEQFxiBgMD3ktLF3RciIDQxN2UyNWIzNGJiNjQ2YWY4ZTM2ZGU4MGFkMzk3ZTNk" alt="报错页面"></p>
<p>这次我根据报错信息，可以看出来大概是ChapterController.java或者PageDto.java的问题了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Required request body is missing: public com.course.server.dto.PageDto com.course.business.controller.admin.ChapterController.list(com.course.server.dto.PageDto)</span><br><span class="line">org.springframeworkhttp.converter.HttpMessageNotReadableException: Required request body is missing: public com.course.server.dto.PageDto com.course.business.controller.admin.ChapterContrller.list(com.course.server.dto.PageDto)</span><br></pre></td></tr></table></figure>

<p>由于项目中ChapterController与课程展示的有些许不同，于是先来看看ChapterController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.business.controller.admin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.course.server.domain.Chapter;</span><br><span class="line"><span class="keyword">import</span> com.course.server.dto.ChapterDto;</span><br><span class="line"><span class="keyword">import</span> com.course.server.dto.PageDto;</span><br><span class="line"><span class="keyword">import</span> com.course.server.service.ChapterService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/chapter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChapterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ChapterController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChapterService chapterService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageDto <span class="title">list</span><span class="params">(<span class="meta">@RequestBody</span> PageDto pageDto)</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;pageDto: &#123;&#125;&quot;</span>, pageDto);</span><br><span class="line">        chapterService.list(pageDto);</span><br><span class="line">        <span class="keyword">return</span> pageDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的学习中了解到，http协议中的请求方法post请求。<br>post请求有多种参数传递时，通过header里的Content-Type来标识<br>常见的两种方式分别是表单和json（流）。</p>
<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/1.jpg?versionId=CAEQFxiBgMDHktLF3RciIDFhNTgwZGY5N2U1OTQ5NzY5MDQyMTM5M2IzYmRhNzkw" alt="笔记"></p>
<p>查询模块运行时采用的是json（流）的方式，所以按照课程给代码加上了@RequestBody的注解<br>回头看代码里的<code>@RequestBody PageDto pageDto</code>，参数为PageDto类型，根据报错感觉一切都好像连起来了<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/2.jpg?versionId=CAEQFxiBgMDukdLF3RciIGJiMzMxOGYzNmJiZTQ1NDU5ZjQ0MjBmZTIxZjMyMDkw" alt="查询网页Content-Type"></p>
<p>虽然出错的大概位置找到了，但为什么会出错我却没有一点头绪。<br>经过一系列关键字某度某歌之后,我看到一篇<a href="https://www.freesion.com/article/1579353496">博客</a><br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/4.jpg?versionId=CAEQFxiBgIDQueHF3RciIGM1YzEwYzdjYWU0MzQ3MjZhMDQ5OTBkYTk3NWI4MWQx" alt="笔记3"></p>
<p>瞎猫碰到死耗子，经过该改动之后,项目确实重新恢复正常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.business.controller.admin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.course.server.domain.Chapter;</span><br><span class="line"><span class="keyword">import</span> com.course.server.dto.ChapterDto;</span><br><span class="line"><span class="keyword">import</span> com.course.server.dto.PageDto;</span><br><span class="line"><span class="keyword">import</span> com.course.server.service.ChapterService;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/chapter&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChapterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ChapterController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChapterService chapterService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageDto <span class="title">list</span><span class="params">(PageDto pageDto)</span> </span>&#123;</span><br><span class="line">        LOG.info(<span class="string">&quot;pageDto: &#123;&#125;&quot;</span>, pageDto);</span><br><span class="line">        chapterService.list(pageDto);</span><br><span class="line">        <span class="keyword">return</span> pageDto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/6.jpg?versionId=CAEQFxiBgMDD0bnO3RciIDI1N2JlNWQ0NjkzNTQ1ODdhZGVhNTMwNzMzMzAyMWZi" alt="后端正常显示"></p>
<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/5.jpg?versionId=CAEQFxiBgMC03OzF3RciIDRlOWY3NWY5Mzc2NjQ4ZDU5NjAzMmVjZWU5ODA1Mjg4" alt="前端正常显示"></p>
<p>很奇怪，明明是以json（流）的方向进行参数传递，结果却通过表单方式的代码正常运行<br>我抱着“既然运行正常，就不管它了吧”的想法，继续开始项目开发。<br>但如果事情那么简单就结束了，或许就不会有这个栏目的开始了。</p>
<h2 id="梅开二度"><a href="#梅开二度" class="headerlink" title="梅开二度"></a>梅开二度</h2><p>以为恢复了数据传输就解决了问题，结果重新将20组数据插入数据库之后又发现了新的问题。<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/9.jpg?versionId=CAEQFxiBgMC5mInP3RciIDc5NWZlYzM1MWI1MTQ2YmJiY2UzNGRhMmZlMzEyNDY5" alt="分页功能失效"></p>
<p>集成的分页插件pagehelper插件没有正确运行，数据则是被直接展示了出来。<br>查看一下Console 发现data: {page: 0, size: 0, total: 20, list: Array(20)}<br>数据并没有按代码的方式进行分页操作。<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/10.jpg?versionId=CAEQFxiBgMD2lKDP3RciIDhiZjkzMGZlMGEyMDRiNzA4NWJkN2RmYWYzYTM0OGZl" alt="查看前端情况"></p>
<p>再检查一下后端模块运行情况，在PageDto.java中写一段toString()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;PageDto&#123;&quot;</span>);</span><br><span class="line">    sb.append(<span class="string">&quot;page=&quot;</span>).append(page);</span><br><span class="line">    sb.append(<span class="string">&quot;, size=&quot;</span>).append(size);</span><br><span class="line">    sb.append(<span class="string">&quot;, total=&quot;</span>).append(total);</span><br><span class="line">    sb.append(<span class="string">&quot;, list=&quot;</span>).append(list);</span><br><span class="line"></span><br><span class="line">    sb.append(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/11.jpg?versionId=CAEQFxiBgICtia3P3RciIDYyMjZjOGQ0NjNhMTQzNzE4NzgzYWE0ZmRlYzViNTRh" alt="查看后端情况"></p>
<p>发现是一点数据都没有啊，那么问题还是要么出现在PageDto.java,要么出现在ChapterController.java里面了。</p>
<h2 id="PageHelper没在干活！"><a href="#PageHelper没在干活！" class="headerlink" title="PageHelper没在干活！"></a>PageHelper没在干活！</h2><p>因为ChapterController.java已经找不到头绪了，我把中心放在了PageDto.java里面<br>根据后端展示的情况，我找到了有在调用PageDto.java里方法的ChapterService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.course.server.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.course.server.domain.Chapter;</span><br><span class="line"><span class="keyword">import</span> com.course.server.domain.ChapterExample;</span><br><span class="line"><span class="keyword">import</span> com.course.server.dto.ChapterDto;</span><br><span class="line"><span class="keyword">import</span> com.course.server.dto.PageDto;</span><br><span class="line"><span class="keyword">import</span> com.course.server.mapper.ChapterMapper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChapterService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ChapterMapper chapterMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(PageDto pageDto)</span> </span>&#123;</span><br><span class="line">        PageHelper.startPage(pageDto.getPage(), pageDto.getSize());</span><br><span class="line">        ChapterExample chapterExample = <span class="keyword">new</span> ChapterExample();</span><br><span class="line">        List&lt;Chapter&gt; chapterList = chapterMapper.selectByExample(chapterExample);</span><br><span class="line">        PageInfo&lt;Chapter&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(chapterList);</span><br><span class="line">        pageDto.setTotal(pageInfo.getTotal());</span><br><span class="line">        List&lt;ChapterDto&gt; chapterDtoList = <span class="keyword">new</span> ArrayList&lt;ChapterDto&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l = chapterList.size(); i &lt; l; i++) &#123;</span><br><span class="line">            Chapter chapter = chapterList.get(i);</span><br><span class="line">            ChapterDto chapterDto = <span class="keyword">new</span> ChapterDto();</span><br><span class="line">            BeanUtils.copyProperties(chapter, chapterDto);</span><br><span class="line">            chapterDtoList.add(chapterDto);</span><br><span class="line">        &#125;</span><br><span class="line">        pageDto.setList(chapterDtoList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚好就是我们的集成分页插件PageHelper的startPage()方法，既然知道是PageDto出现问题，于是就试着给他换一换参数。<br>在经过一轮参数测试之后，意外地发现了PageHelper在罢工的事实。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E5%90%90%E6%A7%BD/12.jpg?versionId=CAEQFxiBgIDSju7P3RciIGJmZmMxYzY0MzZjYjRlZmFhMzk2OGQxMDJkM2Q1MmNh" alt="大型罢工场景"></p>
<h1 id="问题解决方向"><a href="#问题解决方向" class="headerlink" title="问题解决方向"></a>问题解决方向</h1><p>截止于这篇博客发布前，仍没找到解决的方法，所以先聊聊解决方向。<br>一是放弃使用PageHelper，缺个分页插件也无妨。<br>二是更换分页插件， 使用其他同学所提到的sqlHelper。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>blog</tag>
        <tag>Spring Cloud</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>九月伊始</title>
    <url>/2021/09/04/blog/%E4%B9%9D%E6%9C%88%E4%BC%8A%E5%A7%8B/</url>
    <content><![CDATA[<h1 id="暑假总结"><a href="#暑假总结" class="headerlink" title="暑假总结"></a>暑假总结</h1><p>暑假结尾就跟泄了气的皮球一样，既没有学习，也没有沉迷在游戏里面。<br>做翻译的心思也少了许多，自制字幕视频出了三期之后就变回了搬运。<br>不过有看到其他人在进行字幕制作，找个借口就是没必要重复造轮子了（</p>
<h1 id="近期状况"><a href="#近期状况" class="headerlink" title="近期状况"></a>近期状况</h1><p>回校之后，在舍友的带动下开始了高强度的学习。<br>目前在学习如何用Spring Cloud + Vue 做一个前后端分离的项目。<br>是<a href="https://blog.refrigetwo.moe/">老胡</a>和他朋友推荐给我的慕课网课程。<br>本来是打算暑假进行的，由于资金问题而拖到了开学，实在是有点拖自己进度了。<br>做不到和舍友一样的高强度学习，所以我在自己的日程安排表里加入了翻译工作的一项。<br>虽然只是在做老胡的私人翻译，但是能听到一些中文上的建议，可以给自己的短缺做一些填补。</p>
<h1 id="宇宙现状"><a href="#宇宙现状" class="headerlink" title="宇宙现状"></a>宇宙现状</h1><p>结果暑假期间也没能写出一点东西，只能说“慢慢来吧”。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>八月的if</title>
    <url>/2021/08/04/blog/%E5%85%AB%E6%9C%88%E7%9A%84if/</url>
    <content><![CDATA[<h1 id="近况"><a href="#近况" class="headerlink" title="近况"></a>近况</h1><p>嗯，由于前年出去兼职对自己造成的影响。<br>今年的暑假依旧是选择在家度过，但其实说到底还是因为懒。<br>蹲家挺好的，在家里有空调，有网络，还有零食。<br>只要最低的消耗就能好好活下去。<br>不过，虽然现在可以暂时逃避社会，但是我清楚这样的日子只会越来越少。<br>九月份开始就是大二学生了，要忙的事情会更加多。<br>未来还有实习、考专升本等一系列事情在等着我。<br>实在是没有时间，再过像这样的日子了。</p>
<h1 id="关于牧尾宇宙"><a href="#关于牧尾宇宙" class="headerlink" title="关于牧尾宇宙"></a>关于牧尾宇宙</h1><p>如果有看过我博客的朋友，会发现宇宙已经开始更新了。<br>《牧尾同学记事簿》第一话。<br>500字短的不能再短的小文章，讲述的是拉开宇宙序幕的小故事。</p>
<p>主人公，相信大家都不陌生了吧。</p>
<p><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E7%89%A7%E5%B0%BE%E4%BC%8A%E7%B9%94/%E7%B4%A0%E6%9D%90%E7%89%88%E6%9C%AC.jpg?versionId=CAEQExiBgMCEwdrD0xciIGM2MWIxYmIxZTIzYzQxMDJhZGM2OThkMjlhMmZkMDMy" alt="牧尾伊織"></p>
<p>《牧尾同学记事簿》以后会继续以牧尾伊織为主人公，描述自己在创作时的各种奇怪想法。<br>敬请期待。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>比起上一个假期的彻底没有学习，这个学期算是稍微进步了一点，不知道为什么能够坚持刷题。<br>最近在看的番剧，比较在意的是《白砂的水族馆》<br>是一个发生在水族馆里，主题为善待动物，友好待人的美好故事。<br>其中一位主角的声优伊藤美来小姐，也去体验水族馆的工作了。<br>以此为契机，我重新开始了搬运与翻译的工作。<br>加上在学习如何写项目<br>另外还想尝试一下制作视频。<br>这个月应该会很忙，但我想暑假变得充实并不是什么坏事呢。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>牧尾同学记事簿（1）</title>
    <url>/2021/07/21/novel/%E7%89%A7%E5%B0%BE%E5%90%8C%E5%AD%A6%E8%AE%B0%E4%BA%8B%E7%B0%BF/%E7%89%A7%E5%B0%BE%E5%90%8C%E5%AD%A6%E8%AE%B0%E4%BA%8B%E7%B0%BF%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>暑假的某一天。</p>
<p>我保持着一直以来的放假习惯。</p>
<p>盘着双腿坐在椅子上，拿着游戏手柄，目光紧盯着电脑屏幕。</p>
<p>上边是调了十八度的空调呼呼吹出的冷风。</p>
<p>下边则是电脑机箱在不断地让我感受它温热的气息。</p>
<p>音响开着的声音并不大，所以我才能够听清楚她突然之间的发言。</p>
<p>“我想创造一个属于自己的宇宙。”</p>
<p>来自一旁正仰着面躺在我床上的女孩</p>
<p>她望着天花板，像是在思考些什么。</p>
<p>“哈？”我发出了疑惑的声音。</p>
<p>握着游戏手柄的手稍微停了下来，目光也望向了她。</p>
<p>“创造……宇宙？”我把耳朵确切听到的内容重复了一遍。</p>
<p>她像是突然起了兴致，猛地坐了起来。</p>
<p>“呀，你看啊，把可爱的女孩子们，放在同一个宇宙里。”</p>
<p>“嗯……嗯……”我眯起眼睛，尝试将她的话语输入脑中。</p>
<p>“让她们各自有各自的故事，又能够出现交集。”</p>
<p>“嗯……嗯……”</p>
<p>“这不是很棒的事情吗？”</p>
<p>她看向我的眼睛正在闪闪发光。</p>
<p>“所以，你想怎么做？” 我把脸向着电脑屏幕转了回去。</p>
<p>老实说我不太懂，但我大受震撼。</p>
<p>只能一步一步顺着她走了吧。</p>
<p>“怎么做……我不是说了吗？要创造一个属于自己的宇宙！”</p>
<p>“……我就是在问你要怎么创造啊……”我无奈地再次问道。</p>
<p>“呼<del>呼</del>呼~”她笑了笑。</p>
<p>这笑声感觉令我的汗毛竖了起来。</p>
<p>“那当然是在梦中啦，晚安！”</p>
<p>奇怪的答案。</p>
<p>然后她就躺回了下去，这次还顺手盖上了我的被子。</p>
<p>本想说她一下，但感觉不会有啥结果，只是白费口水而已</p>
<p>于是就算了。</p>
<p>“好冷。” 她打了一个喷嚏。</p>
<p>“是谁把空调开那么低的。” 我接过话茬。</p>
<p>“是谁啊？” 她抱怨的声音。</p>
<p>“是你啊。” 我冷淡的声音。</p>
]]></content>
      <categories>
        <category>novel</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Pytorch实现mnist手写数字识别</title>
    <url>/2021/06/27/blog/%E4%BD%BF%E7%94%A8Pytorch%E5%AE%9E%E7%8E%B0mnist%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>我其实根本就不想写这方面内容的文章，不过既然人工智能课的结课作业要写项目文档，我就顺便更一下博客而已。（其实说到底就是逮到机会想水博客而已。）没有学过Python，代码来源自网络，整理一下也能方便日后的自己拿出来学习。<br>下面开始就是作业了。</p>
<h1 id="基于Pytorch的MNIST手写数字识别"><a href="#基于Pytorch的MNIST手写数字识别" class="headerlink" title="基于Pytorch的MNIST手写数字识别"></a>基于Pytorch的MNIST手写数字识别</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>数字识别（Digit Recognition）是计算机从纸质文档,照片,或其他来源接收和理解并识别可读的数字的能力。<br>根据数字来源的产生方式的不同,目前数字识别问题可以区分为手写体数字识别,印刷体数字识别,光学数字识别,自然场景下的数字识别等,具有很大的实际应用价值。目前比较受到关注的问题主要是手写体数字识别,由于其具有MNIST这种大型标准易用的成熟数据集,简单的0-9数字识别已经被作为计算机视觉领域的入门问题。本文通过介绍手写数字识别的应用,并指出传统研究方法及其不足之处;然后引入深度学习的概念,以卷积神经网络为例,详细介绍卷积神经网络的关键技术特点。最后通过一个实例说明卷积神经网络在手写数字识别方面的应用。（此段来源自网络）</p>
<h2 id="项目背景概述-介绍"><a href="#项目背景概述-介绍" class="headerlink" title="项目背景概述/介绍"></a>项目背景概述/介绍</h2><p>MNIST手写数字识别，是一个比较简单的入门项目，就相当于我们在学习编程语言时最开始的Hello World，可以让我们快速地了解构建神经网络的大致过程。<br>这次我们选择使用PyTorch的神经网络框架。PyTorch是torch的python版本，它是由Facebook开源的神经网络框架。<br>Torch 是一个经典的对多维矩阵数据进行操作的张量(tensor)库，在机器学习和其他数学密集型应用有广泛应用。与Tensorflow的静态计算图不同，pytorch的计算图是动态的，可以根据计算需要实时改变计算图。但由于Torch语言采用 Lua，导致在国内一直很小众，并逐渐被支持 Python 的 Tensorflow 抢走用户。作为经典机器学习库 Torch 的端口，PyTorch 为 Python 语言使用者提供了舒适的写代码选择。PyTorch的设计追求最少的封装，尽量避免重复造轮子。不像 TensorFlow 中充斥着session、graph、operation、name_scope、variable、tensor、layer等全新的概念，PyTorch 的设计遵循tensor→variable(autograd)→nn.Module 三个由低到高的抽象层次，分别代表高维数组（张量）、自动求导（变量）和神经网络（层/模块），而且这三个抽象之间联系紧密，可以同时进行修改和操作。 简洁的设计带来的另外一个好处就是代码易于理解。PyTorch的源码只有TensorFlow的十分之一左右，更少的抽象、更直观的设计使得PyTorch的源码十分易于阅读。<br>总的来说，选择Pytorch，是因为它能够在短时间内建立结果，适用于小规模的项目。（其实最主要的是因为老师让我们用Pytorch）</p>
<h2 id="项目实现原理"><a href="#项目实现原理" class="headerlink" title="项目实现原理"></a>项目实现原理</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>安装PyTorch -&gt; 安装mnist -&gt; 通过代码下载MNIST训练集 -&gt; 通过代码定义卷积神经网络 -&gt; 通过代码使用MNIST训练集中的训练库和测试库训练出一个模型MNIST.pth -&gt; 通过模型与定义的卷积神经网络进行识别</p>
<h3 id="PyTorch安装"><a href="#PyTorch安装" class="headerlink" title="PyTorch安装"></a>PyTorch安装</h3><p>根据自己计算机的实际情况在官网 <a href="https://pytorch.org/">https://pytorch.org</a> 安装相应的PyTorch<br>详细安装教程：<a href="https://blog.csdn.net/learningpawn/article/details/106531514">https://blog.csdn.net/learningpawn/article/details/106531514</a></p>
<h3 id="安装Python的mnist库"><a href="#安装Python的mnist库" class="headerlink" title="安装Python的mnist库"></a>安装Python的mnist库</h3><p>打开cmd，输入<code>pip install mnist</code><br>可以通过 <code>pip list</code> 检查自己是否安装相应的库</p>
<h3 id="通过代码进行的操作"><a href="#通过代码进行的操作" class="headerlink" title="通过代码进行的操作"></a>通过代码进行的操作</h3><p>通过代码下载MNIST的训练集和测试集，同时定义卷积神经网络，然后训练出相应的模型，并将其保存，以下为执行代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line">torch.__version__</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BATCH_SIZE=<span class="number">512</span> <span class="comment">#大概需要2G的显存</span></span><br><span class="line">EPOCHS=<span class="number">20</span> <span class="comment"># 总共训练批次</span></span><br><span class="line">DEVICE = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>) <span class="comment"># 让torch判断是否使用GPU，建议使用GPU环境，因为会快很多</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载训练集</span></span><br><span class="line">train_loader = torch.utils.data.DataLoader(</span><br><span class="line">        datasets.MNIST(<span class="string">&#x27;data&#x27;</span>, train=<span class="literal">True</span>, download=<span class="literal">True</span>, </span><br><span class="line">                       transform=transforms.Compose([</span><br><span class="line">                           transforms.ToTensor(),</span><br><span class="line">                           transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                       ])),</span><br><span class="line">        batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载测试集</span></span><br><span class="line">test_loader = torch.utils.data.DataLoader(</span><br><span class="line">        datasets.MNIST(<span class="string">&#x27;data&#x27;</span>, train=<span class="literal">False</span>, transform=transforms.Compose([</span><br><span class="line">                           transforms.ToTensor(),</span><br><span class="line">                           transforms.Normalize((<span class="number">0.1307</span>,), (<span class="number">0.3081</span>,))</span><br><span class="line">                       ])),</span><br><span class="line">        batch_size=BATCH_SIZE, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义卷积神经网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvNet</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># batch*1*28*28（每次会送入batch个样本，输入通道数1（黑白图像），图像分辨率是28x28）</span></span><br><span class="line">        <span class="comment"># 下面的卷积层Conv2d的第一个参数指输入通道数，第二个参数指输出通道数，第三个参数指卷积核的大小</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>) <span class="comment"># 输入通道数1，输出通道数10，核的大小5</span></span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, <span class="number">3</span>) <span class="comment"># 输入通道数10，输出通道数20，核的大小3</span></span><br><span class="line">        <span class="comment"># 下面的全连接层Linear的第一个参数指输入通道数，第二个参数指输出通道数</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">20</span>*<span class="number">10</span>*<span class="number">10</span>, <span class="number">500</span>) <span class="comment"># 输入通道数是2000，输出通道数是500</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">500</span>, <span class="number">10</span>) <span class="comment"># 输入通道数是500，输出通道数是10，即10分类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        in_size = x.size(<span class="number">0</span>) <span class="comment"># 在本例中in_size=512，也就是BATCH_SIZE的值。输入的x可以看成是512*1*28*28的张量。</span></span><br><span class="line">        out = self.conv1(x) <span class="comment"># batch*1*28*28 -&gt; batch*10*24*24（28x28的图像经过一次核为5x5的卷积，输出变为24x24）</span></span><br><span class="line">        out = F.relu(out) <span class="comment"># batch*10*24*24（激活函数ReLU不改变形状））</span></span><br><span class="line">        out = F.max_pool2d(out, <span class="number">2</span>, <span class="number">2</span>) <span class="comment"># batch*10*24*24 -&gt; batch*10*12*12（2*2的池化层会减半）</span></span><br><span class="line">        out = self.conv2(out) <span class="comment"># batch*10*12*12 -&gt; batch*20*10*10（再卷积一次，核的大小是3）</span></span><br><span class="line">        out = F.relu(out) <span class="comment"># batch*20*10*10</span></span><br><span class="line">        out = out.view(in_size, -<span class="number">1</span>) <span class="comment"># batch*20*10*10 -&gt; batch*2000（out的第二维是-1，说明是自动推算，本例中第二维是20*10*10）</span></span><br><span class="line">        out = self.fc1(out) <span class="comment"># batch*2000 -&gt; batch*500</span></span><br><span class="line">        out = F.relu(out) <span class="comment"># batch*500</span></span><br><span class="line">        out = self.fc2(out) <span class="comment"># batch*500 -&gt; batch*10</span></span><br><span class="line">        out = F.log_softmax(out, dim=<span class="number">1</span>) <span class="comment"># 计算log(softmax(x))</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#训练</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">model, device, train_loader, optimizer, epoch</span>):</span></span><br><span class="line">    model.train()</span><br><span class="line">    <span class="keyword">for</span> batch_idx, (data, target) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">        data, target = data.to(device), target.to(device)</span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model(data)</span><br><span class="line">        loss = F.nll_loss(output, target)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="keyword">if</span>(batch_idx+<span class="number">1</span>)%<span class="number">30</span> == <span class="number">0</span>: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\tLoss: &#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                epoch, batch_idx * <span class="built_in">len</span>(data), <span class="built_in">len</span>(train_loader.dataset),</span><br><span class="line">                <span class="number">100.</span> * batch_idx / <span class="built_in">len</span>(train_loader), loss.item()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">model, device, test_loader</span>):</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    test_loss = <span class="number">0</span></span><br><span class="line">    correct = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> data, target <span class="keyword">in</span> test_loader:</span><br><span class="line">            data, target = data.to(device), target.to(device)</span><br><span class="line">            output = model(data)</span><br><span class="line">            test_loss += F.nll_loss(output, target, reduction=<span class="string">&#x27;sum&#x27;</span>).item() <span class="comment"># 将一批的损失相加</span></span><br><span class="line">            pred = output.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>] <span class="comment"># 找到概率最大的下标</span></span><br><span class="line">            correct += pred.eq(target.view_as(pred)).<span class="built_in">sum</span>().item()</span><br><span class="line"></span><br><span class="line">    test_loss /= <span class="built_in">len</span>(test_loader.dataset)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nTest set: Average loss: &#123;:.4f&#125;, Accuracy: &#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)\n&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">        test_loss, correct, <span class="built_in">len</span>(test_loader.dataset),</span><br><span class="line">        <span class="number">100.</span> * correct / <span class="built_in">len</span>(test_loader.dataset)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    model = ConvNet().to(DEVICE)</span><br><span class="line">    optimizer = optim.Adam(model.parameters())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, EPOCHS + <span class="number">1</span>):</span><br><span class="line">        train(model, DEVICE, train_loader, optimizer, epoch)</span><br><span class="line">        test(model, DEVICE, test_loader)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#保存训练完成后的模型</span></span><br><span class="line">    torch.save(model, <span class="string">&#x27;./MNIST.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>以下为测试代码，它将指定进行测试的图片通过opencv转化为灰度图，然后使用前面训练好的模型MNIST.pth和定义好的卷积神经网络进行识别<br>（opencv安装代码 ： <code>pip install python-opencv</code>）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> mnist <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io,transform</span><br><span class="line"><span class="keyword">from</span> train <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line">    model = torch.load(<span class="string">r&#x27;D:/学习/Python/手写数字识别/MNIST.pth&#x27;</span>) <span class="comment">#加载模型</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.<span class="built_in">eval</span>()    <span class="comment">#把模型转为test模式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    img = cv2.imread(<span class="string">&#x27;./numbers/number1.jpg&#x27;</span>, <span class="number">0</span>)  <span class="comment">#以灰度图的方式读取要预测的图片</span></span><br><span class="line">    img = cv2.resize(img, (<span class="number">28</span>, <span class="number">28</span>))</span><br><span class="line"></span><br><span class="line">    height,width=img.shape</span><br><span class="line">    dst=np.zeros((height,width),np.uint8)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            dst[i,j]=<span class="number">255</span>-img[i,j]</span><br><span class="line"></span><br><span class="line">    img = dst</span><br><span class="line"></span><br><span class="line">    img=np.array(img).astype(np.float32)</span><br><span class="line">    img=np.expand_dims(img,<span class="number">0</span>)</span><br><span class="line">    img=np.expand_dims(img,<span class="number">0</span>)<span class="comment">#扩展后，为[1，1，28，28]</span></span><br><span class="line">    img=torch.from_numpy(img)</span><br><span class="line">    img = img.to(device)</span><br><span class="line">    output=model(Variable(img))</span><br><span class="line">    prob = F.softmax(output, dim=<span class="number">1</span>)</span><br><span class="line">    prob = Variable(prob)</span><br><span class="line">    prob = prob.cpu().numpy()  <span class="comment">#用GPU的数据训练的模型保存的参数都是gpu形式的，要显示则先要转回cpu，再转回numpy模式</span></span><br><span class="line">    <span class="built_in">print</span>(prob)  <span class="comment">#prob是10个分类的概率</span></span><br><span class="line">    pred = np.argmax(prob) <span class="comment">#选出概率最大的一个</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;识别结果为：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(pred.item())</span><br></pre></td></tr></table></figure>

<h2 id="项目实现结果-分析"><a href="#项目实现结果-分析" class="headerlink" title="项目实现结果/分析"></a>项目实现结果/分析</h2><p>以下为最终实现的成果，发现手写数字的粗细程度会影响识别的精度，在一定粗细程度的笔触下写下的数字能够实现高精度的识别。</p>
<p>下图为一定粗细程度笔触写下的数字的实现结果，识别波动几乎为无，而且能够完美识别。<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/result.jpg?versionId=CAEQExiBgMCilqyw0hciIDZmM2M1YjFjZjE3NzRjMWM5NzNmMmU5MjhhN2U5ZTI2" alt="正确实现结果"></p>
<p>下图则为过细程度笔触写下的数字的实现结果，可发现识别波动范围比较大，而且出现了识别错误的情况。<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/result2.jpg?versionId=CAEQExiBgID0wMqw0hciIDVlZTY4NTAzNGM1MTQ0NGM4ZjM5ZDczOTY3NGRmMWI2" alt="错误实现结果"></p>
<p>（两图数字皆为博主所写）</p>
<p>要想了解问题为何发生，就得从源头开始查起。<br>MNIST数据集来自美国国家标准与技术研究所（National Institute of Standards and Technology），简称 （NIST）。<br>训练集由来自250个不同人手写的数字构成, 其中50%是高中学生, 50%来自人口普查局的工作人员。测试集也是同样比例的手写数字数据。<br>于是我通过以下代码得到了MNIST训练集和测试集中的手写数字图片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets.mnist <span class="keyword">as</span> mnist</span><br><span class="line"></span><br><span class="line">root=<span class="string">&quot;D:/学习/Python/手写数字识别/程序/data/MNIST/raw&quot;</span></span><br><span class="line">train_set = (</span><br><span class="line">    mnist.read_image_file(os.path.join(root, <span class="string">&#x27;train-images-idx3-ubyte&#x27;</span>)),</span><br><span class="line">    mnist.read_label_file(os.path.join(root, <span class="string">&#x27;train-labels-idx1-ubyte&#x27;</span>))</span><br><span class="line">        )</span><br><span class="line">test_set = (</span><br><span class="line">    mnist.read_image_file(os.path.join(root, <span class="string">&#x27;t10k-images-idx3-ubyte&#x27;</span>)),</span><br><span class="line">    mnist.read_label_file(os.path.join(root, <span class="string">&#x27;t10k-labels-idx1-ubyte&#x27;</span>))</span><br><span class="line">        )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;training set :&quot;</span>,train_set[<span class="number">0</span>].size())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;test set :&quot;</span>,test_set[<span class="number">0</span>].size())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_img</span>(<span class="params">train=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span>(train):</span><br><span class="line">        f=<span class="built_in">open</span>(root+<span class="string">&#x27;train.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        data_path=root+<span class="string">&#x27;/train/&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.exists(data_path)):</span><br><span class="line">            os.makedirs(data_path)</span><br><span class="line">        <span class="keyword">for</span> i, (img,label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(train_set[<span class="number">0</span>],train_set[<span class="number">1</span>])):</span><br><span class="line">            img_path=data_path+<span class="built_in">str</span>(i)+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            io.imsave(img_path,img.numpy())</span><br><span class="line">            f.write(img_path+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(label)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        f.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f = <span class="built_in">open</span>(root + <span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        data_path = root + <span class="string">&#x27;/test/&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> os.path.exists(data_path)):</span><br><span class="line">            os.makedirs(data_path)</span><br><span class="line">        <span class="keyword">for</span> i, (img,label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(test_set[<span class="number">0</span>],test_set[<span class="number">1</span>])):</span><br><span class="line">            img_path = data_path+ <span class="built_in">str</span>(i) + <span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            io.imsave(img_path, img.numpy())</span><br><span class="line">            f.write(img_path + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(label) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">convert_to_img(<span class="literal">True</span>)<span class="comment">#转换训练集</span></span><br><span class="line">convert_to_img(<span class="literal">False</span>)<span class="comment">#转换测试集</span></span><br></pre></td></tr></table></figure>
<p>通过得到的MNIST训练集与测试集中的图片可以看出，虽然他们收集的手写数字皆为不同人所写，但字体的粗细程度几乎相同，或许是使用了同一种笔来进行数据的收集。<br>这才使得字体的粗细程度会影响识别精度的情况发生。<br>根据我的初步理解，要想解决这种情况，得丰富数据库，重新进行深度学习。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>通过这次的学习，进一步了解深度学习，也对卷积神经网络有了一个初步的认识。<br>这个暑假会开展对Python语言的学习，这里的代码算是一个预习了。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Python</tag>
        <tag>Pytorch</tag>
        <tag>mnist</tag>
        <tag>卷积神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>题库第一期</title>
    <url>/2021/05/30/%E9%A2%98%E5%BA%93/%E9%A2%98%E5%BA%93%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>放一点学习过程中，觉得有意思的题目。</p>
<h1 id="进入题库理由"><a href="#进入题库理由" class="headerlink" title="进入题库理由"></a>进入题库理由</h1><p>在学习数据结构的过程中，接触到了栈与队列。<br>栈的特性是先入后出<br>而队列的特性是先入先出<br>明明看起来并不相干，但这二者却都能在通过一点算法的帮助下实现对方。</p>
<h1 id="如何用栈实现队列"><a href="#如何用栈实现队列" class="headerlink" title="如何用栈实现队列"></a>如何用栈实现队列</h1><pre><code>import java.util.Stack;
public class test
&#123;
    private Stack&lt;Integer&gt; a = new Stack&lt;Integer&gt;();       
    private Stack&lt;Integer&gt; b = new Stack&lt;Integer&gt;();

    public void enQueue(int element)
    &#123;
        a.push(element);
        while(!a.empty())
        &#123;
            b.push(a.pop());
        &#125;
    &#125;
    public Integer deQueue()
    &#123;
        if(b.empty())
        &#123;
            if(a.empty())
            &#123;
                return null;
            &#125;
        &#125;
        return b.pop();
    &#125;
    public Integer top()
    &#123;
        return b.peek();
    &#125;
    public boolean empty()
    &#123;
        return b.empty();
    &#125;
    public static void main(String[] args)
    &#123;
        test t = new test();
        t.enQueue(1);
        t.enQueue(2);
        t.enQueue(3);
        t.enQueue(4);
        t.deQueue();
        t.deQueue();
        System.out.println(t.top());
        System.out.println(t.empty());
    &#125;
&#125;
</code></pre>
<h1 id="如何用队列实现栈"><a href="#如何用队列实现栈" class="headerlink" title="如何用队列实现栈"></a>如何用队列实现栈</h1><pre><code>import java.util.LinkedList;
import java.util.Queue;

public class test2 
&#123;
    private Queue&lt;Integer&gt; a = new LinkedList();
    private Queue&lt;Integer&gt; b = new LinkedList();

    public void push(int element)
    &#123;
        a.offer(element);
        while(!b.isEmpty())
        &#123;
            a.offer(b.poll());
        &#125;
        Queue temp = a;
        a = b;
        b = temp;
    &#125;

    public int pop()
    &#123;
        return b.poll();
    &#125;

    public int top()
    &#123;
        return b.peek();
    &#125;

    public boolean empty()
    &#123;
        return b.isEmpty();
    &#125;

    public static void main(String[] args)
    &#123;
        test2 a = new test2();
        a.push(1);
        a.push(2);
        a.pop();
        System.out.println(a.top());
        System.out.println(a.empty());
    &#125;
&#125;
</code></pre>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>以上就是第一期的题库。<br>没错，我又在水博客了。</p>
]]></content>
      <categories>
        <category>Questions</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>题库</tag>
      </tags>
  </entry>
  <entry>
    <title>初识数据结构</title>
    <url>/2021/05/29/blog/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>之前说好要整理出一篇<br>关于如何使用 “GitHub Pages + hexo” 创建博客<br>目前没有一点进展，单纯是因为懒。<br>到六月份就得忙起来了，所以就更没有时间了<br>于是便安排在暑假里吧。<br>由于在自学的过程中，认识到了数据结构<br>我对此起了些许兴趣<br>为了让自己对数据结构有所记忆<br>所以就想先整理出这篇“初识数据结构”的博客。</p>
<h1 id="接触数据结构"><a href="#接触数据结构" class="headerlink" title="接触数据结构"></a>接触数据结构</h1><p>在我开始学习算法的时候，教材首先就给我讲了数据结构的基础<br>这说明数据结构与算法的关联性<br>程序设计 = 数据结构 + 算法。</p>
<p>本着对知识的好奇心，开始了对数据结构的学习，<br>我对于数据结构的理解是：它是计算机存储数据的方式。<br>数据以怎样的组织，怎样的存储格式，被计算机所管理。</p>
<h1 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h1><p>数据结构分为 逻辑结构 以及 物理结构</p>
<p>逻辑结构是指数据与数据之间的关系<br>可以分为<br>线性结构 ：顺序表，栈，队列<br>以及<br>非线性结构 ：树形结构，图形结构</p>
<p>物理结构是指数据在计算机是以何种方式存储的<br>也就是所谓的映像<br>分为<br>顺序存储结构 ：数组<br>和<br>链序存储结构 ：链表</p>
<h1 id="八大数据结构"><a href="#八大数据结构" class="headerlink" title="八大数据结构"></a>八大数据结构</h1><p>Array（数组）<br>Stack（栈）<br>Linked List（链表）<br>Graph（图）<br>Hash（散列表）<br>Queue（队列）<br>Tree（树）<br>Heap（堆）</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年的五一假期</title>
    <url>/2021/05/04/blog/2021%E5%B9%B4%E7%9A%84%E4%BA%94%E4%B8%80%E5%81%87%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>今年的五一假期有5天，虽然前后都要调课，但是由于课本来就不是很多，所以没所谓。<br>反正对处于学习疲倦期的我来说，可以回家的小长假真的是太感激了。</p>
<h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>十年炼金无人问,一朝肉腿天下知。我就是从莱莎这代知晓并且入坑炼金工房系列的人。<br>说来惭愧，写这篇博客的时候还没有通关，因为买了pc版后才发觉这游戏适合用ns玩。<br>于是这时刚好遇上了《不可思议的炼金术士合集》DX版发售的消息，再加上曾经微博上的互关，五风老师的安利。<br>趁这次假期，我就去入手了，苏菲真可爱！（目前进度为：苏菲的炼金工房 ～不可思议书的炼金术士～ DX）<br>如果有时间的话，会写一下游戏感想。（挖个坑，以后会在博客上写一些对玩过的游戏的感想）<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E4%BA%94%E4%B8%80%E5%81%87%E6%9C%9F/5562DFAA95D46B7B0959CD02AFB25040.jpg?versionId=CAEQERiBgMCB9tHeyRciIDNjZGViOWE3YTkwNDRlZWNhYzYwOGYyYzE5NDczNzQy" alt="是我的新游戏哦"></p>
<h1 id="吃的（别问为什么专门弄一个标题）"><a href="#吃的（别问为什么专门弄一个标题）" class="headerlink" title="吃的（别问为什么专门弄一个标题）"></a>吃的（别问为什么专门弄一个标题）</h1><p>在华南秋叶原买游戏时，偶然发现的店，味道不错。<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E4%BA%94%E4%B8%80%E5%81%87%E6%9C%9F/435819689BB3F21AEE308DE013709219.jpg?versionId=CAEQERiBgICC9tHeyRciIGI3NjMzNWNkZDkwMDQ5ODU4MGJjNjY4NDZiMDhkNDU4" alt="章鱼烧"></p>
<p>跟好久没见的网络群友，一起去漫展玩了一天，晚餐自然就是经典的萨莉亚了。<br><img src="https://makiori.oss-cn-beijing.aliyuncs.com/%E4%BA%94%E4%B8%80%E5%81%87%E6%9C%9F/5671C8145163EC6946CFA5DC0B1A340C.jpg?versionId=CAEQERiBgICJ9tHeyRciIDQ5MGViNjRlYzMzMjQ4M2RhYWY1ZmM2ODM3Y2E4ZTY3" alt="萨"></p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>好好地休息了一下，接下来得调整好自己，迎接后面的学习。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
